{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-183ff11fad3a1b71ee68da6537ccc5a803f2a9d8",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/blindAuction.sol": "project/contracts/blindAuction.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/blindAuction.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ncontract BlindAuction {\n    struct Bid {\n        bytes32 blindedBid;\n        uint deposit;\n    }\n\n    // Phases will be set only by external agents and not by time \"now\"\n    // Enum-uint mapping:\n    // Init - 0; Bidding - 1; Reveal - 2; Done - 3\n    enum Phase {Init, Bidding, Reveal, Done}\n     // Owner\n    address payable public beneficiary;\n       // Keep track of the highest bid,bidder\n    address public highestBidder;\n    uint public highestBid =0;\n    // Only one bid allowed per address\n    mapping(address => Bid) public bids;\n    mapping(address => uint) pendingReturns;\n\n    Phase public currentPhase = Phase.Init;\n    event AuctionEnded(address winner, uint highestBid);\n    event BiddingStarted();\n    event RevealStarted ();\n    event AuctionInit();\n    event AuctionDone();\n    // Modifiers\n    modifier validPhase(Phase phase) {require(currentPhase == phase,'phaseError');\n    _;}\n    modifier onlyBeneficiary() {\n\t    require(msg.sender == beneficiary,'onlyBeneficiary'); _;\n\t}\n    constructor() {\n        beneficiary = payable(msg.sender);\n    }\n\n    function advancePhase() public onlyBeneficiary {\n        uint nextPhase = uint(currentPhase) + 1;\n        currentPhase = Phase(nextPhase);\n        if (currentPhase == Phase.Reveal) emit RevealStarted();\n        if (currentPhase == Phase.Bidding) emit BiddingStarted();\n        if (currentPhase == Phase.Init) emit AuctionInit();\n        if (currentPhase == Phase.Done) emit AuctionDone();\n    }\n\n    function bid(bytes32 blindBid) public payable validPhase(Phase.Bidding) {\n        require(msg.sender != beneficiary,'beneficiaryBid');\n        bids[msg.sender] = Bid({\n            blindedBid: blindBid,\n            deposit: msg.value\n        });\n    }\n\n    function reveal(uint value, bytes32 secret) public validPhase(Phase.Reveal) {\n        require(msg.sender != beneficiary, 'beneficiaryReveal');\n        uint refund = 0;\n        Bid storage bidToCheck = bids[msg.sender];\n\n        if (bidToCheck.blindedBid == keccak256(abi.encodePacked(value, secret))) {\n            refund += bidToCheck.deposit;\n            \n            // Direct value comparison - value should already be in Wei\n            if (bidToCheck.deposit >= value) {\n                if (placeBid(msg.sender, value))\n                    refund -= value;\n            }\n        }\n        payable(msg.sender).transfer(refund);\n    }\n\n    // This is an \"internal\" function which means that it\n    // can only be called from the contract itself (or from\n    // derived contracts).\n    function placeBid(address bidder, uint value) internal returns (bool success) {\n        if (value <= highestBid) {\n            return false;\n        }\n        if (highestBidder != address(0)) {\n            pendingReturns[highestBidder] += highestBid;\n        }\n        highestBid = value;\n        highestBidder = bidder;\n\n        return true;\n    }\n\n    // Withdraw a non-winning bid\n    function withdraw() public {\n        uint amount = pendingReturns[msg.sender];\n        if (amount > 0) {\n            pendingReturns[msg.sender] = 0;\n            payable(msg.sender).transfer(amount);\n        }\n    }\n    function auctionEnd() public validPhase(Phase.Done) onlyBeneficiary{\n         if(address(this).balance >= highestBid){\n         beneficiary.transfer(highestBid);\n         }\n        emit AuctionEnded(highestBidder, highestBid);\n    }\n    function closeAuction() public{\n        selfdestruct(beneficiary);\n    }\n}"
      }
    }
  }
}